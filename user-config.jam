import feature ;
import modules ;
import os ;
import path ;
import sequence ;

local rule path-constant.if-exists ( variable : path ? )
{
    path = [ path.make $(path) ] ;
    if [ path.exists $(path) ]
    {
        path-constant $(variable) : $(path) ;
        return true ;
    }
}

# Boost.Build/Extensions configuration
#   Load exteions from $HOME/.local/build.extensions by default
# {{{
path-constant.if-exists extensions_root
  : [ path.make [ sequence.join [ os.home-directories ] /.local/build.extensions ] ]
  ;
if ! $(extensions_root)
{
    import errors ;
    errors.error
      : "user-config.jam requires Boost.Build/Extensions ."
      : "See also: https://github.com/Flast/bulid.extensions ."
      ;
}
modules.load extensions : : $(extensions_root) ;
# }}}
import extensions ;
extensions.import "bind" ;
extensions.import path ;
extensions.import feature ;

path-constant BOOST_ROOT : [ extensions!path.make ~/projects/boost ] ;

# for header cache
modules.poke : HCACHEMAXAGE : -1 ;
modules.poke : HCACHEFILE : [ extensions!path.make ~/.hcache ] ;

# common features {{{
feature.extend <warnings> : extra ;

feature.feature lto : off on : propagated ;

feature.extend <stdlib> : libc++ ;

feature.feature fortify-source : on full : incidental optional ;

feature.feature sanitize : address thread undefined : propagated optional ;

feature.feature std : gnu++98 gnu++03 gnu++0x gnu++11 gnu++1y gnu++14 gnu++1z
                        c++98   c++03   c++0x   c++11   c++1y   c++14   c++1z
                : propagated symmetric ;
# }}}

module gcc # compiler specific flags {{{
{
    import toolset : flags ;
    import feature : values ;

    flags gcc OPTIONS <lto>on : -flto ;
    flags gcc.compile OPTIONS <warnings>extra : -Wall -Wextra -pedantic ;
    flags gcc.compile DEFINES <fortify-source>on   : _FORTIFY_SOURCE=1 ;
    flags gcc.compile DEFINES <fortify-source>full : _FORTIFY_SOURCE=2 ;
    #flags gcc.compile.c++ DEFINES <runtime-debugging>on : _GLIBCXX_DEBUG ;

    flags gcc.compile.c++ USER_OPTIONS <exception-handling>on  : -fexceptions ;
    flags gcc.compile.c++ USER_OPTIONS <exception-handling>off : -fno-exceptions ;

    flags gcc.compile OPTIONS   <sanitize>address   : -fsanitize=address ;
    flags gcc.link    LIBRARIES <sanitize>address   : -lasan ;
    flags gcc.compile OPTIONS   <sanitize>thread    : -fsanitize=thread ;
    flags gcc.link    LIBRARIES <sanitize>thread    : -ltsan ;
    flags gcc.compile OPTIONS   <sanitize>undefined : -fsanitize=undefined ;
    flags gcc.link    LIBRARIES <sanitize>undefined : -lubsan ;

    for local f in [ values <std> ]
    {
        flags gcc.compile.c++ OPTIONS <std>$(f) : -std=$(f) ;
        flags gcc.link        OPTIONS <std>$(f) : -std=$(f) ;
    }
} # }}}
module clang-linux # compiler specific flags {{{
{
    import toolset : flags ;
    import feature : values ;

    flags clang-linux OPTIONS <lto>on : -flto ;
    flags clang-linux.compile OPTIONS <warnings>extra : -Wall -Wextra -pedantic ;
    flags clang-linux OPTIONS <stdlib>libc++ : -stdlib=libc++ ;
}
module clang-darwin
{
    import toolset : flags ;

    flags clang-darwin OPTIONS <lto>on : -flto ;
    flags clang-darwin.compile OPTIONS <warnings>extra : -Wall -Wextra -pedantic ;
    flags clang-darwin OPTIONS <stdlib>libc++ : -stdlib=libc++ ;
}
# }}}

# rule using family {{{
local rule invocation-command ( toolset )
{
    switch $(toolset)
    {
        case gcc   : return g++ ;
        case clang : return clang++ ;
        case *     : return $(toolset) ;
    }
}

local rule using-if-actual ( toolset version ? : options * )
{
    import common ;

    local ic = [ invocation-command $(toolset) ] ;
    local command = $(ic) ;
    if ! "default" in $(version)
    {
        command += $(version) ;
        command = $(command:J=-) ;
    }
    if [ common.get-invocation-command-nodefault $(toolset) : $(ic) : $(command) ]
    {
        version ?= default ;
        using $(toolset) : $(version) : $(command) : $(options) ;
    }
}

local rule using-if ( toolset versions * : options * )
{
    if $(versions)
    {
        for local v in $(versions)
        {
            using-if-actual $(toolset) $(v) : $(options) ;
        }
    }
    else
    {
        # configure toolset with default
        using-if-actual $(toolset) : $(options) ;
    }
}
# }}}

extensions!feature.extend-variant release : <instruction-set>native <fortify-source>on ;

extensions!feature.extend-variant debug : <warnings>extra ;

constant linker-flags
  : --as-needed
  ;

#constant defines
#  :
#  ;

# Project requirements operation helpers {{{
local rule make-conditional ( rulename + )
{
    return <conditional>@$(rulename) ;
}

local rule add-project-requirements ( requirements * )
{
    import project ;

    local p = [ project.current ] ;
    local pa = [ project.attributes [ $(p).project-module ] ] ;
    $(pa).set requirements : $(requirements) ;
}
# }}}

# toolset configurations
module configuration # {{{
{
    # .version.<toolset> {{{
    local rule .version.gcc ( properties * )
    {
        import feature ;
        return [ MATCH ([0-9]+)\.([0-9]+)?\.([0-9]+)?
                  : [ feature.get-values <toolset-gcc:version> : $(properties) ] ] ;
    }
    # }}}

    # error limit {{{
    rule .error-limit ( toolset : properties * )
    {
        local f = <cflags> <cxxflags> ;
        switch $(toolset)
        {
          case gcc : return $(f)-fmax-errors=1  ;
          case clang : return $(f)-ferror-limit=1 ;
        }
    }
    # }}}

    # diagnostics {{{
    rule .diagnostics ( toolset : properties * )
    {
        switch $(toolset)
        {
          case gcc : return [ .diagnostics.gcc $(properties) ] ;
        }
    }
    local rule .diagnostics.gcc ( properties * ) # {{{
    {
        local v = [ .version.gcc $(properties) ] ;
        if ( $(v[1]) > 4 ) || ( $(v[1]) = 4 && $(v[2]) >= 9 )
        {
            local f = <cflags> <cxxflags> ;
            return $(f)-fdiagnostics-color=always $(f)-fdiagnostics-show-caret ;
        }
    } # }}}
    # }}}
}

# configuration helper {{{
IMPORT_MODULE configuration ;

rule lookup-configurator ( name : properties * )
{
    local t = [ feature.get-values <toolset> : $(properties) ] ;
    if .$(name) in [ RULENAMES configuration ]
    {
        return [ configuration..$(name) $(t) : $(properties) ] ;
    }
}
local rule make-lookup-configurator ( name )
{
    return [ extensions!bind.binding lookup-configurator $(name)
              : [ extensions!bind._1 ] ] ;
}
# }}}
# }}}

add-project-requirements
    [ make-conditional
          #[ make-lookup-configurator error-limit ]
          [ make-lookup-configurator diagnostics ]
        ]
    <define>$(defines)
  ;

# using gcc {{{
using-if gcc default
    4.6.0 4.6.1 4.6.2 4.6.3 4.6.4
    4.7.0 4.7.1 4.7.2 4.7.3 4.7.4
    4.8.0 4.8.1 4.8.2 4.8.3
    4.9.0 4.9.1
    5.0
  : #<warnings>extra
      <compileflags>-Wextra
      <compileflags>-pedantic
    <compileflags>-Wno-unused
    <compileflags>-Wno-long-long
    <compileflags>-Winit-self
    <compileflags>-Wformat=2
    <cxxflags>-Wlogical-op
    <cflags>-fcond-mismatch
    <cflags>-std=gnu99
    <linkflags>-Wl,$(linker-flags)
  ;
# }}}

# using clang {{{
using-if clang default
    3.2 3.3 3.4 3.5 3.6
  : #<warnings>extra
      <compileflags>-Wextra
      <compileflags>-pedantic
    <compileflags>-Wno-unused
    <compileflags>-Wno-long-long
    <cflags>-std=gnu99
    <cxxflags>-Wno-c99-extensions
    <linkflags>-Wl,$(linker-flags)
  ;
# }}}

# boost toolsets {{{
path-constant BOOSTBOOK : $(BOOST_ROOT)/tools/boostbook ;

     if [ path-constant.if-exists docbook-xsl : $(BOOSTBOOK)/docbook-xsl-1.78.1 ] { }
else if [ path-constant.if-exists docbook-xsl : $(BOOSTBOOK)/docbook-xsl-1.75.2 ] { }

path-constant.if-exists docbook-dtd : $(BOOSTBOOK)/docbook-dtd-4.2 ;

if $(docbook-xsl) && $(docbook-dtd)
{
    using boostbook : $(docbook-xsl) : $(docbook-dtd) : $(BOOSTBOOK) ;
}

path-constant.if-exists fop : $(BOOSTBOOK)/fop-0.94 ;

if $(fop)
{
    using fop : $(fop) ;
}

if [ path.exists $(BOOST_ROOT)/dist/bin/quickbook ]
{
    using quickbook : $(BOOST_ROOT)/dist/bin/quickbook ;
}
# }}}

# document generators {{{
if [ path.exists /usr/bin/xsltproc ]
{
    using xsltproc : /usr/bin/xsltproc ;
}
if [ path.exists /usr/bin/doxygen ]
{
    using doxygen : /usr/bin/doxygen ;
}
# }}}

